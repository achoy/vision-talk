#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
// assert supported node runtime version
const runtime = require("./runtime");
// require analytics as soon as possible to start measuring execution time
const analytics = require("../lib/analytics");
const alerts = require("../lib/alerts");
const sln = require("../lib/sln");
const args_1 = require("./args");
const copy_1 = require("./copy");
const spinner = require("../lib/spinner");
const errors = require("../lib/error");
const ansiEscapes = require("ansi-escapes");
const detect_1 = require("../lib/detect");
const updater_1 = require("../lib/updater");
function runCommand(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield args.method(...args.options._);
        const res = analytics({
            args: args.options._,
            command: args.command,
        });
        if (result && !args.options.quiet) {
            if (args.options.copy) {
                copy_1.copy(result);
                console.log('Result copied to clipboard');
            }
            else {
                console.log(result);
            }
        }
        return res;
    });
}
function handleError(args, error) {
    return __awaiter(this, void 0, void 0, function* () {
        spinner.clearAll();
        let command = 'bad-command';
        if (error.code === 'VULNS') {
            // this isn't a bad command, so we won't record it as such
            command = args.command;
        }
        else if (!error.stack) { // log errors that are not error objects
            analytics.add('error', JSON.stringify(error));
            analytics.add('command', args.command);
        }
        else {
            // remove vulnerabilities from the errors
            // to keep the logs small
            if (error.stack && error.stack.vulnerabilities) {
                delete error.vulnerabilities;
            }
            if (error.message && error.message.vulnerabilities) {
                delete error.message.vulnerabilities;
            }
            analytics.add('error-message', error.message);
            analytics.add('error', error.stack);
            analytics.add('error-code', error.code);
            analytics.add('command', args.command);
        }
        const res = analytics({
            args: args.options._,
            command,
        });
        if (args.options.debug) {
            console.log(error.stack);
        }
        else {
            if (!args.options.quiet) {
                const result = errors.message(error);
                if (args.options.copy) {
                    copy_1.copy(result);
                    console.log('Result copied to clipboard');
                }
                else {
                    if (`${error.code}`.indexOf('AUTH_') === 0) {
                        // remove the last few lines
                        const erase = ansiEscapes.eraseLines(4);
                        process.stdout.write(erase);
                    }
                    console.log(result);
                }
            }
        }
        return res;
    });
}
function checkRuntime() {
    if (!runtime.isSupported(process.versions.node)) {
        console.error(`${process.versions.node} is an unsupported nodejs ` +
            `runtime! Supported runtime range is '${runtime.supportedRange}'`);
        console.error('Please upgrade your nodejs runtime version and try again.');
        process.exit(1);
    }
}
// Check if user specify package file name as part of path
// and throw error if so.
function checkPaths(args) {
    for (const path of args.options._) {
        if (typeof path === 'string' && detect_1.isPathToPackageFile(path)) {
            throw new Error(`Not a recognised option did you mean --file=${path}. ` +
                'Check other options by running snyk --help');
        }
    }
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        updater_1.updateCheck();
        checkRuntime();
        const args = args_1.args(process.argv);
        if (args.options.file && args.options.file.match(/\.sln$/)) {
            sln.updateArgs(args);
        }
        let res = null;
        let failed = false;
        try {
            checkPaths(args);
            res = yield runCommand(args);
        }
        catch (error) {
            failed = true;
            res = yield handleError(args, error);
        }
        if (!args.options.json) {
            console.log(alerts.displayAlerts());
        }
        if (!process.env.TAP && failed) {
            process.exit(1);
        }
        return res;
    });
}
const cli = main().catch((e) => {
    console.log('super fail', e.stack);
    process.exit(1);
});
if (module.parent) {
    module.exports = cli;
}
//# sourceMappingURL=index.js.map