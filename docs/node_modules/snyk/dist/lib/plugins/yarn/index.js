"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("then-fs");
const _ = require("lodash");
const Debug = require("debug");
const snyk_nodejs_lockfile_parser_1 = require("snyk-nodejs-lockfile-parser");
const snyk = require("../../");
const debug = Debug('snyk');
function inspect(root, targetFile, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const isLockFileBased = targetFile.endsWith('yarn.lock');
        const targetFileFullPath = path.resolve(root, targetFile);
        const isShrinkwrapPresent = yield fs.exists(path.join(path.dirname(targetFileFullPath), 'npm-shrinkwrap.json'));
        if (getRuntimeVersion() < 6) {
            options.traverseNodeModules = true;
            debug('Falling back to node_modules traversal for yarn.lock projects on Node < 6');
            const isNodeModulesFolderPresent = yield fs.exists(path.join(root, 'node_modules'));
            if (!isNodeModulesFolderPresent) {
                // throw a custom error
                throw new Error('Missing node_modules folder: we can\'t test ' +
                    'without dependencies.\nPlease run \'yarn install\' first.');
            }
        }
        if (isLockFileBased && !isShrinkwrapPresent && !options.traverseNodeModules) {
            return {
                plugin: {
                    name: 'snyk-nodejs-lockfile-parser',
                    runtime: process.version,
                },
                package: yield generateDependenciesFromLockfile(root, options, targetFile),
            };
        }
        // Traverse node modules.
        return {
            plugin: {
                name: 'snyk-resolve-deps',
                runtime: process.version,
            },
            package: yield snyk.modules(root, Object.assign({}, options, { noFromArrays: true })),
        };
    });
}
exports.inspect = inspect;
function getRuntimeVersion() {
    return parseInt(process.version.slice(1).split('.')[0], 10);
}
function generateDependenciesFromLockfile(root, options, targetFile) {
    return __awaiter(this, void 0, void 0, function* () {
        const lockFileFullPath = path.resolve(root, targetFile);
        if (!(yield fs.exists(lockFileFullPath))) {
            throw new Error(`Lockfile ${targetFile} not found at location: ${lockFileFullPath}`);
        }
        const fullPath = path.parse(lockFileFullPath);
        const manifestFileFullPath = path.resolve(fullPath.dir, 'package.json');
        if (!(yield fs.exists(manifestFileFullPath))) {
            throw new Error(`Manifest file yarn.lock not found at location: ${manifestFileFullPath}`);
        }
        if (!manifestFileFullPath && lockFileFullPath) {
            throw new Error(`Detected a lockfile at location: ${lockFileFullPath}\nHowever the yarn.lock is missing!`);
        }
        const [manifestFile, lockFile] = yield Promise.all([
            yield fs.readFile(manifestFileFullPath, 'utf-8'),
            yield fs.readFile(lockFileFullPath, 'utf-8'),
        ]);
        const defaultManifestFileName = path.relative(root, manifestFileFullPath);
        const strictOutOfSync = _.get(options, 'strictOutOfSync') !== 'false';
        return snyk_nodejs_lockfile_parser_1.buildDepTree(manifestFile, lockFile, options.dev, snyk_nodejs_lockfile_parser_1.LockfileType.yarn, strictOutOfSync, defaultManifestFileName);
    });
}
//# sourceMappingURL=index.js.map