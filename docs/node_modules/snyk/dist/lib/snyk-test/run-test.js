"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const _ = require("lodash");
const fs = require("then-fs");
const pathUtil = require("path");
const moduleToObject = require("snyk-module");
const depGraphLib = require("@snyk/dep-graph");
const analytics = require("../analytics");
const config = require("../config");
const detect = require("../../lib/detect");
const plugins = require("../plugins");
const ModuleInfo = require("../module-info");
const isCI = require("../is-ci");
const request = require("../request");
const snyk = require("../");
const spinner = require("../spinner");
const common = require("./common");
const gemfileLockToDependencies = require("../../lib/plugins/rubygems/gemfile-lock-to-dependencies");
const legacy_1 = require("./legacy");
// tslint:disable-next-line:no-var-requires
const debug = require('debug')('snyk');
function runTest(packageManager, root, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const policyLocations = [options['policy-path'] || root];
        // TODO: why hasDevDependencies is always false?
        const hasDevDependencies = false;
        const spinnerLbl = 'Querying vulnerabilities database...';
        try {
            const payload = yield assemblePayload(root, options, policyLocations);
            const filesystemPolicy = payload.body && !!payload.body.policy;
            const depGraph = payload.body && payload.body.depGraph;
            let dockerfilePackages;
            if (payload.body && payload.body.docker && payload.body.docker.dockerfilePackages) {
                dockerfilePackages = payload.body.docker.dockerfilePackages;
            }
            yield spinner(spinnerLbl);
            let res = yield sendPayload(payload, hasDevDependencies);
            if (depGraph) {
                res = legacy_1.convertTestDepGraphResultToLegacy(res, depGraph, packageManager, options.severityThreshold);
            }
            analytics.add('vulns-pre-policy', res.vulnerabilities.length);
            res.filesystemPolicy = filesystemPolicy;
            if (!options['ignore-policy']) {
                const policy = yield snyk.policy.loadFromText(res.policy);
                res = policy.filter(res, root);
            }
            analytics.add('vulns', res.vulnerabilities.length);
            if (res.docker && dockerfilePackages) {
                res.vulnerabilities = res.vulnerabilities.map((vuln) => {
                    const dockerfilePackage = dockerfilePackages[vuln.name.split('/')[0]];
                    if (dockerfilePackage) {
                        vuln.dockerfileInstruction = dockerfilePackage.instruction;
                    }
                    vuln.dockerBaseImage = res.docker.baseImage;
                    return vuln;
                });
            }
            res.uniqueCount = countUniqueVulns(res.vulnerabilities);
            return res;
        }
        finally {
            spinner.clear(spinnerLbl)();
        }
    });
}
function sendPayload(payload, hasDevDependencies) {
    const filesystemPolicy = payload.body && !!payload.body.policy;
    return new Promise((resolve, reject) => {
        request(payload, (error, res, body) => {
            if (error) {
                return reject(error);
            }
            if (res.statusCode !== 200) {
                const err = new Error(body && body.error ?
                    body.error :
                    res.statusCode);
                err.userMessage = body && body.userMessage;
                // this is the case where a local module has been tested, but
                // doesn't have any production deps, but we've noted that they
                // have dep deps, so we'll error with a more useful message
                if (res.statusCode === 404 && hasDevDependencies) {
                    err.code = 'NOT_FOUND_HAS_DEV_DEPS';
                }
                else {
                    err.code = res.statusCode;
                }
                if (res.statusCode === 500) {
                    debug('Server error', body.stack);
                }
                return reject(err);
            }
            body.filesystemPolicy = filesystemPolicy;
            resolve(body);
        });
    });
}
function assemblePayload(root, options, policyLocations) {
    let isLocal;
    if (options.docker) {
        isLocal = true;
        policyLocations = policyLocations.filter((loc) => {
            return loc !== root;
        });
    }
    else {
        isLocal = fs.existsSync(root);
    }
    analytics.add('local', isLocal);
    if (isLocal) {
        return assembleLocalPayload(root, options, policyLocations);
    }
    return assembleRemotePayload(root, options);
}
function assembleLocalPayload(root, options, policyLocations) {
    return __awaiter(this, void 0, void 0, function* () {
        options.file = options.file || detect.detectPackageFile(root);
        const plugin = plugins.loadPlugin(options.packageManager, options);
        const moduleInfo = ModuleInfo(plugin, options.policy);
        const analysisType = options.docker ? 'docker' : options.packageManager;
        const spinnerLbl = 'Analyzing ' + analysisType + ' dependencies for ' +
            pathUtil.relative('.', pathUtil.join(root, options.file || ''));
        try {
            yield spinner(spinnerLbl);
            const inspectRes = yield moduleInfo.inspect(root, options.file, options);
            const pkg = inspectRes.package;
            if (_.get(inspectRes, 'plugin.packageManager')) {
                options.packageManager = inspectRes.plugin.packageManager;
            }
            const baseImageFromDockerfile = _.get(pkg, 'docker.baseImage');
            if (!baseImageFromDockerfile && options['base-image']) {
                pkg.docker = pkg.docker || {};
                pkg.docker.baseImage = options['base-image'];
            }
            if (baseImageFromDockerfile && inspectRes.plugin.imageLayers) {
                analytics.add('BaseImage', baseImageFromDockerfile);
                analytics.add('imageLayers', inspectRes.plugin.imageLayers);
            }
            if (_.get(pkg, 'files.gemfileLock.contents')) {
                const gemfileLockBase64 = pkg.files.gemfileLock.contents;
                const gemfileLockContents = Buffer.from(gemfileLockBase64, 'base64').toString();
                pkg.dependencies = gemfileLockToDependencies(gemfileLockContents);
            }
            const depGraph = yield depGraphLib.legacy.depTreeToGraph(pkg, options.packageManager);
            analytics.add('policies', policyLocations.length);
            analytics.add('packageManager', options.packageManager);
            analytics.add('packageName', pkg.name);
            analytics.add('packageVersion', pkg.version);
            analytics.add('package', pkg.name + '@' + pkg.version);
            let policy;
            if (policyLocations.length > 0) {
                try {
                    policy = yield snyk.policy.load(policyLocations, options);
                }
                catch (err) {
                    // note: inline catch, to handle error from .load
                    //   if the .snyk file wasn't found, it is fine
                    if (err.code !== 'ENOENT') {
                        throw err;
                    }
                }
            }
            const payload = {
                method: 'POST',
                url: config.API + '/test-dep-graph',
                json: true,
                headers: {
                    'x-is-ci': isCI,
                    'authorization': 'token ' + snyk.api,
                },
                qs: common.assembleQueryString(options),
                body: {
                    depGraph,
                    targetFile: pkg.targetFile || options.file,
                    projectNameOverride: options.projectName,
                    policy: policy && policy.toString(),
                    docker: pkg.docker,
                },
            };
            return payload;
        }
        finally {
            spinner.clear(spinnerLbl)();
        }
    });
}
function assembleRemotePayload(root, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkg = moduleToObject(root);
        debug('testing remote: %s', pkg.name + '@' + pkg.version);
        analytics.add('packageName', pkg.name);
        analytics.add('packageVersion', pkg.version);
        analytics.add('packageManager', options.packageManager);
        analytics.add('package', pkg.name + '@' + pkg.version);
        const encodedName = encodeURIComponent(pkg.name + '@' + pkg.version);
        const payload = {
            method: 'GET',
            url: `${config.API}/vuln/${options.packageManager}/${encodedName}`,
            json: true,
            headers: {
                'x-is-ci': isCI,
                'authorization': 'token ' + snyk.api,
            },
        };
        payload.qs = common.assembleQueryString(options);
        return payload;
    });
}
function countUniqueVulns(vulns) {
    const seen = {};
    const count = vulns.reduce((acc, curr) => {
        if (!seen[curr.id]) {
            seen[curr.id] = true;
            acc++;
        }
        return acc;
    }, 0);
    return count;
}
module.exports = runTest;
//# sourceMappingURL=run-test.js.map