"use strict";
// Module that provides functions to collect and build response after all
// analyses' are done.
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function buildResponse(runtime, depsAnalysis, dockerfileAnalysis, options) {
    var deps = depsAnalysis.package.dependencies;
    var dockerfilePkgs = collectDockerfilePkgs(dockerfileAnalysis, deps);
    var finalDeps = excludeBaseImageDeps(deps, dockerfilePkgs, options);
    var plugin = pluginMetadataRes(runtime, depsAnalysis);
    var pkg = packageRes(depsAnalysis, dockerfileAnalysis, dockerfilePkgs, finalDeps);
    return {
        plugin: plugin,
        package: pkg,
    };
}
exports.buildResponse = buildResponse;
function pluginMetadataRes(runtime, depsAnalysis) {
    return {
        name: 'snyk-docker-plugin',
        runtime: runtime,
        packageManager: depsAnalysis.packageManager,
        dockerImageId: depsAnalysis.imageId,
        imageLayers: depsAnalysis.imageLayers,
    };
}
function packageRes(depsAnalysis, dockerfileAnalysis, dockerfilePkgs, deps) {
    return tslib_1.__assign({}, depsAnalysis.package, { dependencies: deps, docker: tslib_1.__assign({}, depsAnalysis.package.docker, dockerfileAnalysis, { dockerfilePackages: dockerfilePkgs, binaries: depsAnalysis.binaries }) });
}
function collectDockerfilePkgs(dockerAnalysis, deps) {
    if (!dockerAnalysis)
        return;
    return getDockerfileDependencies(dockerAnalysis.dockerfilePackages, deps);
}
// Iterate over the dependencies list; if one is introduced by the dockerfile,
// flatten its dependencies and append them to the list of dockerfile
// packages. This gives us a reference of all transitive deps installed via
// the dockerfile, and the instruction that installed it.
function getDockerfileDependencies(dockerfilePackages, dependencies) {
    var _loop_1 = function (dependencyName) {
        if (dependencies.hasOwnProperty(dependencyName)) {
            var sourceOrName = dependencyName.split('/')[0];
            var dockerfilePackage_1 = dockerfilePackages[sourceOrName];
            if (dockerfilePackage_1) {
                collectDeps(dependencies[dependencyName]).forEach(function (dep) {
                    dockerfilePackages[dep.split('/')[0]] = tslib_1.__assign({}, dockerfilePackage_1);
                });
            }
        }
    };
    for (var dependencyName in dependencies) {
        _loop_1(dependencyName);
    }
    return dockerfilePackages;
}
function collectDeps(pkg) {
    // ES5 doesn't have Object.values, so replace with Object.keys() and map()
    return pkg.dependencies
        ? Object.keys(pkg.dependencies)
            .map(function (name) { return pkg.dependencies[name]; })
            .reduce(function (allDeps, pkg) {
            return allDeps.concat(collectDeps(pkg));
        }, Object.keys(pkg.dependencies))
        : [];
}
// Skip processing if option disabled or dockerfilePkgs is undefined. We
// can't exclude anything in that case, because we can't tell which deps are
// from dockerfile and which from base image.
function excludeBaseImageDeps(deps, dockerfilePkgs, options) {
    if (options === void 0) { options = {}; }
    if (!options['exclude-base-image-vulns'] || !dockerfilePkgs) {
        return deps;
    }
    return extractDockerfileDeps(deps, dockerfilePkgs);
}
function extractDockerfileDeps(allDeps, dockerfilePkgs) {
    return Object.keys(allDeps)
        .filter(function (depName) { return dockerfilePkgs[depName]; })
        .reduce(function (extractedDeps, depName) {
        extractedDeps[depName] = allDeps[depName];
        return extractedDeps;
    }, {});
}
//# sourceMappingURL=response-builder.js.map